# 20230907

## プロジェクトの誤った構成

### プロジェクトの構造

- Go言語のメンテナーは、Goのプロジェクトの構造化について強い規約をもっていない
  - 長年にわたって1つのレイアウトが現れている
    - project-layout(<https://github.com/golang-standards/project-layout>)

> - /cmd —メインのソースファイルです。foo アプリケーションの main.go は /cmd/foo/main.go に置かれます。
> - /internal —他の人のアプリケーションやライブラリにインポートされたくないプライベート なコードです。
> - /pkg —他の人に公開したい公開コードです。
> - /test —追加の外部テストとテストデータです。Go の単体テストは、ソースファイルと同じ パッケージに置きます。しかし、公開 API テストや統合テストなどは、/test に置くべきです。
> - /conﬁgs —設定ファイルです。
> - /docs —設計ドキュメントとユーザードキュメントです。
> - /examples —アプリケーションあるいは公開ライブラリのコード例です。
> - /api —API 契約ファイル（Swagger や Protocol Buffers など）です。
> - /web —ウェブアプリケーション固有のアセット（静的ファイルなど）です。
> - /build —パッケージングと継続的インテグレーションのファイルです。
> - /scripts —解析やインストールなどのためのスクリプトです。
> - /vendor —アプリケーションが依存しているものです（たとえば、Go の依存モジュール）。

- Russ Coxがgolang-standardsという組織の下にプロジェクトが置かれていることを主な理由として批判している点に注意
  - あくまで参考程度

### パッケージ構成

- 全体構成については正直好み
- パッケージについては、従うべきベストプラクティスがある
  - プロジェクトを複雑にしすぎるので、早まったパッケージ化を避ける
    - 単純な構成にして、中身を理解してからプロジェクトを進化させるようにした方がよい
- パッケージ間の結合を減らすために、公開すべきものはできるだけ少なくし、不必要な公開要素は隠蔽しておくべき
  - もし、ある要素を公開するかどうか迷ったら、デフォルトで公開しないようにすべき
  - あとで公開する必要があることがわかったらコードを修正できる

## ユーティリティパッケージの作成

- よくあるbad practiceとして、utils、common、baseといった共有パッケージの作成について解説する

```go

package util

func NewStringSet(...string) map[string]struct{} {
 // ...
 return nil
}

func SortStringSet(map[string]struct{}) []string {
 // ...
 return nil
}

```

- ここでの問題は、utilが無意味だということ
  - パッケージが提供するものについて何の見積もりも与えない無意味な名前である
- ユーティリティパッケージの代わりに、stringsetのような表現に富むパッケージ名を作成すべき

```go

package stringset

func NewStringSet(...string) map[string]struct{} {
 // ...
 return nil
}

func SortStringSet(map[string]struct{}) []string {
 // ...
 return nil
}
```

## まとめ

> - シャドウされた変数を避けることで、間違った変数を参照したり、読み手を混乱させたりする ような間違いを防げます。
> - ネストしたレベルを避け、ハッピーパスを左側に揃えることで、メンタルコードモデルの構築 が容易になります。
> - 変数を初期化する場合、init 関数ではエラー処理が制限され、状態の処理とテストが複雑に なることを覚えておいてください。ほとんどの場合、初期化は特定の関数として処理すべき
> - ゲッターとセッターを無理に使うのは、Go では慣用的ではありません。実用的であること、 そして効率と特定の慣用表現に盲従することとの間の適切なバランスを見つけることが、進む べき道であるべきです。
> - 抽象化は作られるのではなく、発見されるべきです。不必要な複雑さを防ぐために、インタ フェースは必要なときに作り、必要だと予想したときには作らないようにします。すなわち、 少なくとも抽象化が有効であることを証明できる場合にのみ作ってください。
> - インタフェースをクライアント側に置くことで、不必要な抽象化を避けられます。
> - 柔軟性に関して制限されないようにするために、関数はほとんどの場合、インタフェースではなく、具象的な実装を返すようにすべきです。逆に、関数は可能な限りインタフェースを受け取るようにすべきです。
> - json.Marshalのような任意の型を受け入れるか返す必要がある場合のみ、any を使ってください。そうではない場合、anyは意味のある情報を提供せず、呼び出し元が任意のデータ 型でメソッドを呼び出せてしまうため、コンパイル時の問題につながる可能性があります。
> - ジェネリクスと型パラメータを使い、要素や振る舞いを抽出することで、決まり切ったコードを書くことを防げます。しかし、型パラメータを時期尚早に使うのではなく、具体的な必要性が確認できた場合にのみ使ってください。そうでなければ、不必要な抽象化と複雑さを招くことになります。
> - 型埋め込みも、決まり切ったコードを避けるのに役立ちます。しかし、隠ぺいしておくべき フィールドが公開されるという可視性の問題にならないようにしてください。
> - オプションを便利で使いやすいAPI として扱うには、関数オプションパターンを使ってくだ さい。
> •project-layout といったレイアウトに従うことは、Go プロジェクトの構築を開始するよい方法になり得ます。とりわけ、新たなプロジェクトを標準化するために既存の慣習を探している場合にはそうです。
> - 命名は、アプリケーション設計の重要な要素です。common、util、sharedなどのパッケージを作っても、読み手にはあまり価値をもたらしません。そのようなパッケージは、意味のある具体的なパッケージ名にリファクタリングしてください。
> - 混乱やバグにつながる、変数とパッケージの名前の衝突を避け、それぞれに一意な名前を使ってください。それが可能ではない場合、パッケージ名と変数名を区別するために修飾子を変更 するインポートエイリアスを使ってください。それが難しければ、やはり衝突しないよい名前 を考えてください。
> - クライアントや保守担当者がコードの目的を理解するのを助けるために、公開された要素を文書化してください。
> - コードの品質と一貫性を高めるために、リンターとフォーマッタを使ってください。
>
