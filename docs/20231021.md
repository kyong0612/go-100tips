# 20231021

## データアライメントを意識していない

- データアライメントとは、CPUによるメモリアクセスを高速化するために、データの割り当て方を整えること
- この概念を理解しないと、余計なメモリ消費を招き、さらには性能低下にも繋がる

```go
var i int32
var j int64
```

- データアライメントが行われないとすると、64ビットアーキテクチャでは、これらの2つの変数は以下のように割り当てられる
  - j変数の割り当ては、2ワードにまたがる
  - CPUがjを読み込もうとすると、1回のメモリアクセスではなく、2回のメモリアクセスが必要になる
- このようなことにならないように、変数のメモリアドレスは変数自身の大きささの倍数であるべき

## ヒープとスタック

- スタック
  - デフォルトのメモリで、特定のゴルーチンのローカル変数をすべて格納するLIFO(last-in, first-out)データ構造
  - goroutineが起動すると、スタック空間として2KBの連続したメモリを取得できる
  - この大きさは実行時に固定されているわけではなく、必要に応じて大きくなったり小さくなったりする
- Goでは関数が呼び出されると、その関数だけがアクセスできるメモリ上の区間としてスタックフレームが作成される

```go
func main() {
    a := 3
    b := 2

    c := sumValue(a, b)
    println(c)
}

// go:noinline // インライン展開を無効にする
func sumValue(x, y int) int {
    z := x + y
    return z
}
```

- c変数をヒープに確保するfmt.Printlnの代わりにprintln組み込み関数を使っている
- 関数呼び出しを発生させるためにsumValue関数のインライン展開を無効にしている
- 関数をリターンするとき、Goは空き容量を回収するために変数のメモリ領域を開放することはない
  - しかし、これらの変数はもはやアクセスできず、親関数が新たな変数をスタックに割り当てると、以前の割り当て両機は上書きされる
  - ある意味、スタックは自己クリーニングが行われ、GCといった追加機構は必要としない

- ヒープメモリは、すべてのgoroutineが共有するメモリのプール
- スタックは自己クリーニングが行われ、単一のゴルーチンによりアクセスされる
- 逆に、ヒープはGCという外部システムによってクリーニングされなければならない
- ヒープの割り当てが増えれば触れるほど、GCへの負担をかけることになる
- GCが実行されうと、利用可能なCPU容量の25%を使い、ミリ単位の「ストップ・ザ・ワールド」遅延(アプリケーションが一時停止するフェーズ)を発生させる可能性がある
