# 20230927

## 並行処理

- 扱う内容
  - 並行処理と並列処理を理解する
  - 並行処理が必ずしも早いとは限らない理由
  - CPUバウンドとI／Oバウンドの作業負荷の影響
  - チャネルとミューテックスの使い分け
  - データ競合（data race）と競合状態(race condition)の違いを理解する
  - Goのコンテキストを扱う

- ここ数十年の間にCPUベンダーはクロック速度だけに集中することをやめた
- そのかわり、最近のCPUはマルチコアやハイパースレッディング(同じ物理コア上に複数の論理コアを搭載すること)で設計されている
- これらのアーキテクチャを利用するために、ソフトウェア開発者にとって並行処理が重要になってきた

## 並行処理と並列処理を混同する

- 並行処理とは、1度に多くを扱うこと。並列処理とは一度に多くを行うこと
- 並行処理が並列処理を可能にする

- 並行処理
  - 構造に関するもので、別々の並行スレッドがそれぞれ別々に取り組めるステップを導入することで、逐次的な実行を並行的なものに変えられる
- 並列処理
  - 実行に関するもので、ステップレベルで並行スレッドを増やすことができる

## 並行処理は常に高速であると考える

- 多くの開発者は、並行的な解決方法が、逐次的な解決方法とりも常に高速であると信じているがそれば間違い
- 解決方法の具体的な性能は、構造(並行性)の効率、どの部分を並列に処理できるか、計算単位間の競合のレベルなど、多くの要因に依存する

## Goのスケジューリング

- スレッドはOSが実行できる最小の処理単位
- あるプロセスが複数の処理を同時に実行したい場合、複数のスレットを生成する
- これらのスレッドは次のような状態が可能
  - 並列的（concurrent）
    - 2つ以上のスレッドが時間的に重なりあって、開始・実行・完了できる
  - 並列的(parallel)
  　　- 同じタスクを1度に複数書い実行できる
- OSは、次の事項に対して、スレッドのプロセスを最適にスケジューリングする責任がある
  - すべてのスレッドは、あまり時間をあけずにCPUサイクルを消費できる
  - 作業負荷は、複数のCPUコアにできるだけ均等に分散される
- Go開発者はスレッドを直接作成できないが、アプリケーションレベルのスレッドと考えられるゴルーチンを作成できる
- しかしOSスレッドがOSにとってCPUコアに対してコンテキストスイッチのオン/オフを行うのに対して、ゴルーチンはGoランタイムによってOSスレッドに対してコンテキストスイッチのon/offを行う
- またOSスレッドと比較して、ゴルーチンのスタックメモリサイズは小さく、Go1.4以降のgorutineでは2KBである
  - OSスレッドはOSに依存した、例えばLinux/x86-32では、デフォルトのスタックの大きさは2MB

## 並行マージソート

- マージソートアルゴリズムがどのようにどうするか
  - リストを2つのサブリストに繰り返し分割し、それぞれのサブリストがたんいつの　要素で構成されるまで分割した後、サブリクトをマージして結果をソートされたリストにする
  - 各分割操作はリストを2つのサブリストに分割し、マージ操作は2つのサブリストをマージしてソートされたリストにする
  